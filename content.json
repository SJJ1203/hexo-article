{"meta":{"title":"木的疏忽","subtitle":"","description":"","author":"木的疏忽","url":"http://www.woodend.cn","root":"/"},"pages":[{"title":"archives","date":"2021-05-19T08:44:49.000Z","updated":"2021-05-19T08:44:49.496Z","comments":true,"path":"archives/index.html","permalink":"http://www.woodend.cn/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-19T09:35:25.000Z","updated":"2021-06-08T05:39:07.384Z","comments":false,"path":"categories/index.html","permalink":"http://www.woodend.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-17T08:06:47.000Z","updated":"2021-06-08T05:39:07.384Z","comments":false,"path":"tags/index.html","permalink":"http://www.woodend.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-06-04T08:59:01.742Z","updated":"2021-06-04T08:59:01.742Z","comments":true,"path":"404.html","permalink":"http://www.woodend.cn/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"}],"posts":[{"title":"test write","slug":"blog/test","date":"2021-06-07T10:14:40.902Z","updated":"2021-06-07T10:14:40.900Z","comments":true,"path":"blog/test/","link":"","permalink":"http://www.woodend.cn/blog/test/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 博客logo Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment 标签页的处理 标签页的路由标签页的切换标签页的删除在上面的设计中父页面是一个唯一的值，带领着它的子页面，所以 父页面的路径存储一定不能携带参数 ，但是 子页面的路径存储必须得携带参数。我们在 TabComponent 监听了路由切换事件，并通过它记录路由信息，这部分处理就在事件监听之中： let menuUrl &#x3D; menu.url, sameTabChild &#x3D; false, childComponent &#x3D; null; this.menuList.forEach(item &#x3D;&gt; { &#x2F;&#x2F; 如果是子页面标签 if (item.isChild &amp;&amp; !sameTabChild) { &#x2F;&#x2F; 相同的子页面组件名 不同的地址 if (item.componentName &#x3D;&#x3D;&#x3D; menu.componentName &amp;&amp; item.url !&#x3D;&#x3D; menuUrl) { sameTabChild &#x3D; true; childComponent &#x3D; item; } &#x2F;&#x2F; 当前页是子页面 子页面的子页面 if (menu.isChild &amp;&amp; item.parComponent &#x3D;&#x3D;&#x3D; menu.componentName ) { sameTabChild &#x3D; true; childComponent &#x3D; item; } } }); &#x2F;&#x2F; 即将打开的页面为相同的子页面 if (sameTabChild) { const indexOfChild &#x3D; this.menuList.findIndex(p &#x3D;&gt; p.componentName &#x3D;&#x3D;&#x3D; childComponent.componentName); this.menuList.splice(indexOfChild, 1); &#x2F;&#x2F; 删除原【子页面】记录值 } else if (menu.isChild &#x3D;&#x3D;&#x3D; undefined) { &#x2F;&#x2F; 为了确保唯一性，剔除可能存在的参数 const indexParam &#x3D; menu.url.indexOf(&#39;?&#39;); menuUrl &#x3D; menu.url.substring(0, indexParam &#x3D;&#x3D;&#x3D; -1 ? menu.url.length : indexParam); } 前文已经说了切换本质是路由跳转，而拿到的地址是网页 Url ，所以得先提取出参数部分转换为对象才能跳转。 nzSelectChange(event) { this.currentIndex &#x3D; event.index; const menu &#x3D; this.menuList[this.currentIndex], temp &#x3D; menu.url.indexOf(&#39;?&#39;); const params &#x3D; temp &#x3D;&#x3D;&#x3D; -1 ? null : this.getUrlParams(menu.url.substring(temp + 1, menu.url.length)); const url &#x3D; temp &#x3D;&#x3D;&#x3D; -1 ? menu.url : menu.url.substring(0, temp &#x3D;&#x3D;&#x3D; -1 ? menu.url.length : temp); this.router.navigate([url], { queryParams: params, &#x2F;&#x2F; 存放可能的参数 skipLocationChange: true }) } &#x2F;&#x2F; Url 参数转 对象 getUrlParams(url) { if (url &#x3D;&#x3D;&#x3D; &#39;&#39;) return null; let hash, myJson &#x3D; {}, hashes &#x3D; url.slice(url.indexOf(&#39;?&#39;) + 1).split(&#39;&amp;&#39;); for (let i &#x3D; 0; i &lt; hashes.length; i++) { hash &#x3D; hashes[i].split(&#39;&#x3D;&#39;); myJson[hash[0]] &#x3D; decodeURIComponent(hash[1]); } return myJson; }大致的删除逻辑上文已经描述了，代码部分： &#x2F;&#x2F; 关闭选项标签 closeUrl(menu) { &#x2F;&#x2F; 如果只有一个不可以关闭 if (this.menuList.length &#x3D;&#x3D;&#x3D; 1) return; &#x2F;&#x2F; 如果当前只剩下父页面和对应子页面，则不可以关闭父页面 if (this.menuList.length &#x3D;&#x3D;&#x3D; 2) { if (this.menuList.some(item &#x3D;&gt; item.isChild &amp;&amp; (item.parComponent &#x3D;&#x3D;&#x3D; menu.componentName || item.commonComponent &#x3D;&#x3D;&#x3D; menu.componentName))) { return; } } &#x2F;&#x2F; 当前关闭的是第几个路由 const index &#x3D; this.menuList.findIndex(p &#x3D;&gt; p.url &#x3D;&#x3D;&#x3D; menu.url); if (index &#x3D;&#x3D;&#x3D; -1) { &#x2F;&#x2F; 子页面的子页面返回子页面时造成的 （坏笑 return; } &#x2F;&#x2F; 寻找可能存在的子页面 const childComponent &#x3D; this.menuList.filter(item &#x3D;&gt; this.menuList[index].isChild &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.parComponent &#x3D;&#x3D;&#x3D; this.menuList[index].componentName) || []; &#x2F;&#x2F; 寻找可能存在的子页面的剩下子页面 this.menuList.filter(item &#x3D;&gt; this.menuList[index].isChild &#x3D;&#x3D;&#x3D; undefined &#x2F;&#x2F; 本身必须是父页面 &amp;&amp; item.commonComponent &#x3D;&#x3D;&#x3D; this.menuList[index].componentName &#x2F;&#x2F; 祖先 &amp;&amp; item.parComponent !&#x3D;&#x3D; this.menuList[index].componentName &#x2F;&#x2F; 不是第一个子页面 ).forEach(item &#x3D;&gt; { childComponent.push(item); }); &#x2F;&#x2F; 删除 if (childComponent.length &#x3D;&#x3D;&#x3D; 0) { this.deleteTabs(menu); } else { this.modal.confirm({ nzContent: &#39;【&#39; + childComponent[0].title + &#39;】页将一并关闭，是否继续？&#39;, nzCancelText: &#39;否&#39;, nzOkText: &#39;是&#39;, nzOkType: &#39;danger&#39;, nzOnOk: () &#x3D;&gt; { childComponent.forEach(item &#x3D;&gt; { this.deleteTabs(menu, item); }) } }); } } &#x2F;&#x2F; 执行 Tab 删除 deleteTabs(menu, childComponent &#x3D; null) { const index &#x3D; this.menuList.findIndex(p &#x3D;&gt; p.url &#x3D;&#x3D;&#x3D; menu.url); const indexMenuParam &#x3D; menu.url.indexOf(&#39;?&#39;); const path &#x3D; menu.url.substring(0, indexMenuParam &#x3D;&#x3D;&#x3D; -1 ? menu.url.length : indexMenuParam) + &#39;_&#39; + menu.componentName; this.menuList.splice(index, 1); &#x2F;&#x2F; 删除父 SimpleReuseStrategy.deleteRouteSnapshot(path); &#x2F;&#x2F; 删除复用 &#x2F;&#x2F; 删除子 if (childComponent) { const indexOfChild &#x3D; this.menuList.findIndex(p &#x3D;&gt; p.componentName &#x3D;&#x3D;&#x3D; childComponent.componentName); const indexChildParam &#x3D; childComponent.url.indexOf(&#39;?&#39;); const childPath &#x3D; childComponent.url.substring(0, indexChildParam &#x3D;&#x3D;&#x3D; -1 ? childComponent.url.length : indexChildParam) + &#39;_&#39; + childComponent.componentName; this.menuList.splice(indexOfChild, 1); &#x2F;&#x2F; 删除子页面 SimpleReuseStrategy.deleteRouteSnapshot(childPath); &#x2F;&#x2F; 删除子页面复用 } this.settingsService.setMenuList(this.menuList); &#x2F;&#x2F; 记录 &#x2F;&#x2F; 如果当前删除的对象是当前选中的，那么需要跳转 if (this.currentUrl &#x3D;&#x3D;&#x3D; menu.url) { &#x2F;&#x2F; 显示上一个选中 let menu &#x3D; this.menuList[index - 1]; if (!menu) {&#x2F;&#x2F; 如果上一个没有下一个选中 menu &#x3D; this.menuList[index]; } &#x2F;&#x2F; 跳转路由 this.router.navigate([menu.url]); } }","categories":[{"name":"blog","slug":"blog","permalink":"http://www.woodend.cn/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.woodend.cn/tags/hexo/"}]},{"title":"Springboot集成JSP, jar部署/war部署","slug":"deploy/springboot-jsp-jar","date":"2021-06-03T07:14:31.000Z","updated":"2021-06-03T07:14:31.000Z","comments":true,"path":"deploy/springboot-jsp-jar/","link":"","permalink":"http://www.woodend.cn/deploy/springboot-jsp-jar/","excerpt":"前几天老大丢过来一个Springboot的项目, 让我把项目跑起来。顺便让我看看改造成本，以及能否循环再利用。本来想着又能偷懒一会了, 但是看到项目中还有JSP文件, 眉头一皱意识到并没有那么简单 😐 果然本地通过idea跑项目没问题, jar发布测试环境就有访问不了了, 所以写下这踩坑记录😭","text":"前几天老大丢过来一个Springboot的项目, 让我把项目跑起来。顺便让我看看改造成本，以及能否循环再利用。本来想着又能偷懒一会了, 但是看到项目中还有JSP文件, 眉头一皱意识到并没有那么简单 😐 果然本地通过idea跑项目没问题, jar发布测试环境就有访问不了了, 所以写下这踩坑记录😭 项目简介 项目的技术栈 后端：SpringBoot、jpa 前端：JSP、Thymeleaf、Bootstrap、EasyPOI 部署 (一)、多次重定向问题 1. 服务部署，启动 $ java -jar demo.jar 2. 启动正常，访问出错 xxx将您重定向的次数过多 尝试清除Cookie 3. 排查代码 这问题一出现首先想到代码中有没有设置重定向，查看登录拦截设置了重定向，但是不至于会多次重定向啊。 毕竟本地正常运行，所以我想看看到底是什么请求被重定向了，所以将请求路径打印一下 log.info(&quot;登录拦截，被拦截的请求路径: &#123;&#125;&quot;, request.getServletPath()); 打印结果 登录拦截，被拦截的请求路径: /error 4. 查看登录拦截的放行路径 accept_uri = &#123;&quot;/login/**&quot;, &quot;/static/**&quot;&#125;; 到此, 原来是每次请求首页的时候，boot服务找不到指定的页面（model），所以重定向到error, 但是error请求又被登录拦截器拦截，重定向到登录页面，然后登录页面又找不到 index(首页) ===&gt; /error ===&gt; /login ===&gt; /error ===&gt; /login… 原来真正的错误被 /error 给覆盖了 😐 修改方式: 将 /error 加入到 accept_uri 中，实现在拦截器中放行 (二)、找不到指定页面问题 1. 找不到页面 错误信息 2. 排查问题 毕竟出身baidu工程师，咱baidu一下就ok 😏 原来是Springboot集成的jsp，在打成jar包部署的时候，并没有将静态jsp资源打入jar包内 jar内容 3. 解决方案 jar方式 &lt;packing&gt;jar&lt;/packing&gt; pom文件配置 &lt;build&gt; &lt;resources&gt; &lt;!--意为 将webapp目录下的所有文件打包到复制到 jar包中 META-INF/resources中--&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;!--需要使用 Springboot 1.4.2.RELEASE，因为相应的maven plugin只支持到改版本--&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; war方式 &lt;packing&gt;war&lt;/packing&gt; 这里就不具体详解如何打成 war 包了，各大博客网站都有相关的教程。说个我发布 war 的时候遇到的问题。 我将打好的 demo.war 包放到 tomcat 的 webapp 目录下，按理说启动的就可以正常的访问到了。结果我忘了 tomcat 最基本的使用方法了…直接访问了 http://localhost:8081 提示了 tomcat 的 404 页面。 其实访问 tomcat 的 webapp 目录下服务，需要将目录作为 contextPath 加上才可以正常访问，ROOT 目录的话就代表可以 / 直接访问 参考资料: https://blog.csdn.net/ctwy291314/article/details/88976712 https://blog.csdn.net/qq_40807739/article/details/87862968","categories":[{"name":"deploy","slug":"deploy","permalink":"http://www.woodend.cn/categories/deploy/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://www.woodend.cn/tags/Springboot/"},{"name":"tomcat","slug":"tomcat","permalink":"http://www.woodend.cn/tags/tomcat/"}]},{"title":"JsonFormat格式化时间","slug":"json/jackson/JsonFormat","date":"2021-05-28T09:11:31.000Z","updated":"2021-05-28T09:11:31.000Z","comments":true,"path":"json/jackson/JsonFormat/","link":"","permalink":"http://www.woodend.cn/json/jackson/JsonFormat/","excerpt":"关于jackson的注解 [^@JsonFormat][^@JsonFormat]: jackson格式化时间注解@JsonFormat(pattern = “yyyy-MM-dd”)","text":"关于jackson的注解 [^@JsonFormat][^@JsonFormat]: jackson格式化时间注解@JsonFormat(pattern = “yyyy-MM-dd”) 引入jacksonMaven方式&lt;!-- jackson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; Gradle 方式// Gradle 引入依赖 compile group: &#39;com.fasterxml.jackson.core&#39;, name: &#39;jackson-core&#39;, version: &#39;2.12.1&#39; compile group: &#39;com.fasterxml.jackson.core&#39;, name: &#39;jackson-databind&#39;, version: &#39;2.12.1&#39; // 如没有用到注解去配置可不用引入此依赖 compile group: &#39;com.fasterxml.jackson.core&#39;, name: &#39;jackson-annotations&#39;, version: &#39;2.12.1&#39; 格式化时间使用方式方式一：配置实体类的属性上@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;) private Date curDateTime; 方式二：配置文件中全局配置spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 注意事项：当设置全局配置时间格式化时，同时也在实体类的属性上使用@JsonFormate注解。此时以实体类属性上的注解配置的时间格式为准，此配置将会优先于全局配置","categories":[{"name":"json","slug":"json","permalink":"http://www.woodend.cn/categories/json/"},{"name":"jackson","slug":"json/jackson","permalink":"http://www.woodend.cn/categories/json/jackson/"}],"tags":[{"name":"jackson","slug":"jackson","permalink":"http://www.woodend.cn/tags/jackson/"}]},{"title":"anime","slug":"anime/anime","date":"2021-05-27T05:55:31.000Z","updated":"2021-05-27T05:55:31.000Z","comments":true,"path":"anime/anime/","link":"","permalink":"http://www.woodend.cn/anime/anime/","excerpt":"Bilibili","text":"Bilibili 小猫","categories":[{"name":"anime","slug":"anime","permalink":"http://www.woodend.cn/categories/anime/"}],"tags":[{"name":"anime","slug":"anime","permalink":"http://www.woodend.cn/tags/anime/"}]},{"title":"fuck-categories","slug":"fuck-categories","date":"2021-05-19T09:18:31.000Z","updated":"2021-05-20T09:18:31.000Z","comments":true,"path":"fuck-categories/","link":"","permalink":"http://www.woodend.cn/fuck-categories/","excerpt":"自定义md文章和生成的博客静态文件管理规则","text":"自定义md文章和生成的博客静态文件管理规则 创建新的文章$ hexo new post [文件名称] 将会创建到source/_post/目录下，这里我为了将md文章按照我创建的分类定位，在source/_post/目录下我创建了分类目录，将对应的md文章放入相应的目录中。 将md文章进行分类管理permalink 设置博客访问地址的规则。 permalink: :category/:title-:hash/ 上述规则所产生的效果就是：https://www.woodend.cn/blog/Deploy-Hexo-e7140e18b72a其在public/下生成以分类名命名的目录，配合 post_asset_folder: true 将会生成如下目录结构 public/blog/Deploy-Hexo-e7140e18b72a/index.html 但是上述的配置只能分类管理hexo部署生成后的静态文件，md文章都是在source/_post/目录下的。所以我们可以/source/_post目录下来直接创建分类的目录，区分md文章，同时在生成静态文件之后也会是相同的目录.","categories":[{"name":"blog","slug":"blog","permalink":"http://www.woodend.cn/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.woodend.cn/tags/hexo/"}]}],"categories":[{"name":"blog","slug":"blog","permalink":"http://www.woodend.cn/categories/blog/"},{"name":"deploy","slug":"deploy","permalink":"http://www.woodend.cn/categories/deploy/"},{"name":"json","slug":"json","permalink":"http://www.woodend.cn/categories/json/"},{"name":"jackson","slug":"json/jackson","permalink":"http://www.woodend.cn/categories/json/jackson/"},{"name":"anime","slug":"anime","permalink":"http://www.woodend.cn/categories/anime/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.woodend.cn/tags/hexo/"},{"name":"Springboot","slug":"Springboot","permalink":"http://www.woodend.cn/tags/Springboot/"},{"name":"tomcat","slug":"tomcat","permalink":"http://www.woodend.cn/tags/tomcat/"},{"name":"jackson","slug":"jackson","permalink":"http://www.woodend.cn/tags/jackson/"},{"name":"anime","slug":"anime","permalink":"http://www.woodend.cn/tags/anime/"}]}