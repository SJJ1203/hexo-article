{"meta":{"title":"木的疏忽","subtitle":"","description":"","author":"木的疏忽","url":"http://www.woodend.cn","root":"/"},"pages":[{"title":"archives","date":"2021-05-19T08:44:49.000Z","updated":"2021-05-19T08:44:49.496Z","comments":true,"path":"archives/index.html","permalink":"http://www.woodend.cn/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-19T09:35:25.000Z","updated":"2021-05-19T09:39:14.954Z","comments":false,"path":"categories/index.html","permalink":"http://www.woodend.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-17T08:06:47.000Z","updated":"2021-05-19T09:39:37.387Z","comments":false,"path":"tags/index.html","permalink":"http://www.woodend.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"fuck-categories","slug":"fuck-categories","date":"2021-05-19T09:18:31.000Z","updated":"2021-05-20T09:18:31.000Z","comments":true,"path":"操蛋的分类页面/fuck-categories-0d6a65d8ec8d/","link":"","permalink":"http://www.woodend.cn/%E6%93%8D%E8%9B%8B%E7%9A%84%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2/fuck-categories-0d6a65d8ec8d/","excerpt":"fuck everything!","text":"fuck everything!","categories":[{"name":"操蛋的分类页面","slug":"操蛋的分类页面","permalink":"http://www.woodend.cn/categories/%E6%93%8D%E8%9B%8B%E7%9A%84%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2/"}],"tags":[{"name":"操蛋的标签页面","slug":"操蛋的标签页面","permalink":"http://www.woodend.cn/tags/%E6%93%8D%E8%9B%8B%E7%9A%84%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%9D%A2/"}]},{"title":"test copy","slug":"copy","date":"2021-05-19T08:01:23.961Z","updated":"2021-05-19T08:00:13.514Z","comments":true,"path":"blog/copy-3728e2ff5a1e/","link":"","permalink":"http://www.woodend.cn/blog/copy-3728e2ff5a1e/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 博客logo Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 标签页的处理标签页的路由标签页的切换标签页的删除在上面的设计中父页面是一个唯一的值，带领着它的子页面，所以 父页面的路径存储一定不能携带参数 ，但是 子页面的路径存储必须得携带参数。我们在 TabComponent 监听了路由切换事件，并通过它记录路由信息，这部分处理就在事件监听之中： let menuUrl &#x3D; menu.url, sameTabChild &#x3D; false, childComponent &#x3D; null; this.menuList.forEach(item &#x3D;&gt; { &#x2F;&#x2F; 如果是子页面标签 if (item.isChild &amp;&amp; !sameTabChild) { &#x2F;&#x2F; 相同的子页面组件名 不同的地址 if (item.componentName &#x3D;&#x3D;&#x3D; menu.componentName &amp;&amp; item.url !&#x3D;&#x3D; menuUrl) { sameTabChild &#x3D; true; childComponent &#x3D; item; } &#x2F;&#x2F; 当前页是子页面 子页面的子页面 if (menu.isChild &amp;&amp; item.parComponent &#x3D;&#x3D;&#x3D; menu.componentName ) { sameTabChild &#x3D; true; childComponent &#x3D; item; } } }); &#x2F;&#x2F; 即将打开的页面为相同的子页面 if (sameTabChild) { const indexOfChild &#x3D; this.menuList.findIndex(p &#x3D;&gt; p.componentName &#x3D;&#x3D;&#x3D; childComponent.componentName); this.menuList.splice(indexOfChild, 1); &#x2F;&#x2F; 删除原【子页面】记录值 } else if (menu.isChild &#x3D;&#x3D;&#x3D; undefined) { &#x2F;&#x2F; 为了确保唯一性，剔除可能存在的参数 const indexParam &#x3D; menu.url.indexOf(&#39;?&#39;); menuUrl &#x3D; menu.url.substring(0, indexParam &#x3D;&#x3D;&#x3D; -1 ? menu.url.length : indexParam); } 前文已经说了切换本质是路由跳转，而拿到的地址是网页 Url ，所以得先提取出参数部分转换为对象才能跳转。 nzSelectChange(event) { this.currentIndex &#x3D; event.index; const menu &#x3D; this.menuList[this.currentIndex], temp &#x3D; menu.url.indexOf(&#39;?&#39;); const params &#x3D; temp &#x3D;&#x3D;&#x3D; -1 ? null : this.getUrlParams(menu.url.substring(temp + 1, menu.url.length)); const url &#x3D; temp &#x3D;&#x3D;&#x3D; -1 ? menu.url : menu.url.substring(0, temp &#x3D;&#x3D;&#x3D; -1 ? menu.url.length : temp); this.router.navigate([url], { queryParams: params, &#x2F;&#x2F; 存放可能的参数 skipLocationChange: true }) } &#x2F;&#x2F; Url 参数转 对象 getUrlParams(url) { if (url &#x3D;&#x3D;&#x3D; &#39;&#39;) return null; let hash, myJson &#x3D; {}, hashes &#x3D; url.slice(url.indexOf(&#39;?&#39;) + 1).split(&#39;&amp;&#39;); for (let i &#x3D; 0; i &lt; hashes.length; i++) { hash &#x3D; hashes[i].split(&#39;&#x3D;&#39;); myJson[hash[0]] &#x3D; decodeURIComponent(hash[1]); } return myJson; }大致的删除逻辑上文已经描述了，代码部分： &#x2F;&#x2F; 关闭选项标签 closeUrl(menu) { &#x2F;&#x2F; 如果只有一个不可以关闭 if (this.menuList.length &#x3D;&#x3D;&#x3D; 1) return; &#x2F;&#x2F; 如果当前只剩下父页面和对应子页面，则不可以关闭父页面 if (this.menuList.length &#x3D;&#x3D;&#x3D; 2) { if (this.menuList.some(item &#x3D;&gt; item.isChild &amp;&amp; (item.parComponent &#x3D;&#x3D;&#x3D; menu.componentName || item.commonComponent &#x3D;&#x3D;&#x3D; menu.componentName))) { return; } } &#x2F;&#x2F; 当前关闭的是第几个路由 const index &#x3D; this.menuList.findIndex(p &#x3D;&gt; p.url &#x3D;&#x3D;&#x3D; menu.url); if (index &#x3D;&#x3D;&#x3D; -1) { &#x2F;&#x2F; 子页面的子页面返回子页面时造成的 （坏笑 return; } &#x2F;&#x2F; 寻找可能存在的子页面 const childComponent &#x3D; this.menuList.filter(item &#x3D;&gt; this.menuList[index].isChild &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.parComponent &#x3D;&#x3D;&#x3D; this.menuList[index].componentName) || []; &#x2F;&#x2F; 寻找可能存在的子页面的剩下子页面 this.menuList.filter(item &#x3D;&gt; this.menuList[index].isChild &#x3D;&#x3D;&#x3D; undefined &#x2F;&#x2F; 本身必须是父页面 &amp;&amp; item.commonComponent &#x3D;&#x3D;&#x3D; this.menuList[index].componentName &#x2F;&#x2F; 祖先 &amp;&amp; item.parComponent !&#x3D;&#x3D; this.menuList[index].componentName &#x2F;&#x2F; 不是第一个子页面 ).forEach(item &#x3D;&gt; { childComponent.push(item); }); &#x2F;&#x2F; 删除 if (childComponent.length &#x3D;&#x3D;&#x3D; 0) { this.deleteTabs(menu); } else { this.modal.confirm({ nzContent: &#39;【&#39; + childComponent[0].title + &#39;】页将一并关闭，是否继续？&#39;, nzCancelText: &#39;否&#39;, nzOkText: &#39;是&#39;, nzOkType: &#39;danger&#39;, nzOnOk: () &#x3D;&gt; { childComponent.forEach(item &#x3D;&gt; { this.deleteTabs(menu, item); }) } }); } } &#x2F;&#x2F; 执行 Tab 删除 deleteTabs(menu, childComponent &#x3D; null) { const index &#x3D; this.menuList.findIndex(p &#x3D;&gt; p.url &#x3D;&#x3D;&#x3D; menu.url); const indexMenuParam &#x3D; menu.url.indexOf(&#39;?&#39;); const path &#x3D; menu.url.substring(0, indexMenuParam &#x3D;&#x3D;&#x3D; -1 ? menu.url.length : indexMenuParam) + &#39;_&#39; + menu.componentName; this.menuList.splice(index, 1); &#x2F;&#x2F; 删除父 SimpleReuseStrategy.deleteRouteSnapshot(path); &#x2F;&#x2F; 删除复用 &#x2F;&#x2F; 删除子 if (childComponent) { const indexOfChild &#x3D; this.menuList.findIndex(p &#x3D;&gt; p.componentName &#x3D;&#x3D;&#x3D; childComponent.componentName); const indexChildParam &#x3D; childComponent.url.indexOf(&#39;?&#39;); const childPath &#x3D; childComponent.url.substring(0, indexChildParam &#x3D;&#x3D;&#x3D; -1 ? childComponent.url.length : indexChildParam) + &#39;_&#39; + childComponent.componentName; this.menuList.splice(indexOfChild, 1); &#x2F;&#x2F; 删除子页面 SimpleReuseStrategy.deleteRouteSnapshot(childPath); &#x2F;&#x2F; 删除子页面复用 } this.settingsService.setMenuList(this.menuList); &#x2F;&#x2F; 记录 &#x2F;&#x2F; 如果当前删除的对象是当前选中的，那么需要跳转 if (this.currentUrl &#x3D;&#x3D;&#x3D; menu.url) { &#x2F;&#x2F; 显示上一个选中 let menu &#x3D; this.menuList[index - 1]; if (!menu) {&#x2F;&#x2F; 如果上一个没有下一个选中 menu &#x3D; this.menuList[index]; } &#x2F;&#x2F; 跳转路由 this.router.navigate([menu.url]); } }","categories":[{"name":"blog","slug":"blog","permalink":"http://www.woodend.cn/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.woodend.cn/tags/hexo/"}]},{"title":"Deploy Hexo","slug":"Deploy-Hexo","date":"2021-05-18T10:14:40.935Z","updated":"2021-05-18T10:14:40.931Z","comments":true,"path":"blog/Deploy-Hexo-a514cba9ac6d/","link":"","permalink":"http://www.woodend.cn/blog/Deploy-Hexo-a514cba9ac6d/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"blog","slug":"blog","permalink":"http://www.woodend.cn/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.woodend.cn/tags/hexo/"}]}],"categories":[{"name":"操蛋的分类页面","slug":"操蛋的分类页面","permalink":"http://www.woodend.cn/categories/%E6%93%8D%E8%9B%8B%E7%9A%84%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2/"},{"name":"blog","slug":"blog","permalink":"http://www.woodend.cn/categories/blog/"}],"tags":[{"name":"操蛋的标签页面","slug":"操蛋的标签页面","permalink":"http://www.woodend.cn/tags/%E6%93%8D%E8%9B%8B%E7%9A%84%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%9D%A2/"},{"name":"hexo","slug":"hexo","permalink":"http://www.woodend.cn/tags/hexo/"}]}