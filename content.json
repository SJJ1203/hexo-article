{"meta":{"title":"木的疏忽","subtitle":"","description":"","author":"木的疏忽","url":"http://www.woodend.cn","root":"/"},"pages":[{"title":"archives","date":"2021-05-19T08:44:49.000Z","updated":"2021-05-19T08:44:49.496Z","comments":true,"path":"archives/index.html","permalink":"http://www.woodend.cn/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-19T09:35:25.000Z","updated":"2021-05-19T09:39:14.954Z","comments":false,"path":"categories/index.html","permalink":"http://www.woodend.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-17T08:06:47.000Z","updated":"2021-05-19T09:39:37.387Z","comments":false,"path":"tags/index.html","permalink":"http://www.woodend.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Deploy Hexo","slug":"blog/Deploy-Hexo","date":"2021-05-20T07:38:52.666Z","updated":"2021-05-20T07:38:52.666Z","comments":true,"path":"blog/Deploy-Hexo-f5f9ee6be04c/","link":"","permalink":"http://www.woodend.cn/blog/Deploy-Hexo-f5f9ee6be04c/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"blog","slug":"blog","permalink":"http://www.woodend.cn/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.woodend.cn/tags/hexo/"}]},{"title":"test copy","slug":"blog/copy","date":"2021-05-20T07:38:52.666Z","updated":"2021-05-20T07:38:52.666Z","comments":true,"path":"blog/copy-035ab7d8ee94/","link":"","permalink":"http://www.woodend.cn/blog/copy-035ab7d8ee94/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 博客logo Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 标签页的处理标签页的路由标签页的切换标签页的删除在上面的设计中父页面是一个唯一的值，带领着它的子页面，所以 父页面的路径存储一定不能携带参数 ，但是 子页面的路径存储必须得携带参数。我们在 TabComponent 监听了路由切换事件，并通过它记录路由信息，这部分处理就在事件监听之中： let menuUrl &#x3D; menu.url, sameTabChild &#x3D; false, childComponent &#x3D; null; this.menuList.forEach(item &#x3D;&gt; { &#x2F;&#x2F; 如果是子页面标签 if (item.isChild &amp;&amp; !sameTabChild) { &#x2F;&#x2F; 相同的子页面组件名 不同的地址 if (item.componentName &#x3D;&#x3D;&#x3D; menu.componentName &amp;&amp; item.url !&#x3D;&#x3D; menuUrl) { sameTabChild &#x3D; true; childComponent &#x3D; item; } &#x2F;&#x2F; 当前页是子页面 子页面的子页面 if (menu.isChild &amp;&amp; item.parComponent &#x3D;&#x3D;&#x3D; menu.componentName ) { sameTabChild &#x3D; true; childComponent &#x3D; item; } } }); &#x2F;&#x2F; 即将打开的页面为相同的子页面 if (sameTabChild) { const indexOfChild &#x3D; this.menuList.findIndex(p &#x3D;&gt; p.componentName &#x3D;&#x3D;&#x3D; childComponent.componentName); this.menuList.splice(indexOfChild, 1); &#x2F;&#x2F; 删除原【子页面】记录值 } else if (menu.isChild &#x3D;&#x3D;&#x3D; undefined) { &#x2F;&#x2F; 为了确保唯一性，剔除可能存在的参数 const indexParam &#x3D; menu.url.indexOf(&#39;?&#39;); menuUrl &#x3D; menu.url.substring(0, indexParam &#x3D;&#x3D;&#x3D; -1 ? menu.url.length : indexParam); } 前文已经说了切换本质是路由跳转，而拿到的地址是网页 Url ，所以得先提取出参数部分转换为对象才能跳转。 nzSelectChange(event) { this.currentIndex &#x3D; event.index; const menu &#x3D; this.menuList[this.currentIndex], temp &#x3D; menu.url.indexOf(&#39;?&#39;); const params &#x3D; temp &#x3D;&#x3D;&#x3D; -1 ? null : this.getUrlParams(menu.url.substring(temp + 1, menu.url.length)); const url &#x3D; temp &#x3D;&#x3D;&#x3D; -1 ? menu.url : menu.url.substring(0, temp &#x3D;&#x3D;&#x3D; -1 ? menu.url.length : temp); this.router.navigate([url], { queryParams: params, &#x2F;&#x2F; 存放可能的参数 skipLocationChange: true }) } &#x2F;&#x2F; Url 参数转 对象 getUrlParams(url) { if (url &#x3D;&#x3D;&#x3D; &#39;&#39;) return null; let hash, myJson &#x3D; {}, hashes &#x3D; url.slice(url.indexOf(&#39;?&#39;) + 1).split(&#39;&amp;&#39;); for (let i &#x3D; 0; i &lt; hashes.length; i++) { hash &#x3D; hashes[i].split(&#39;&#x3D;&#39;); myJson[hash[0]] &#x3D; decodeURIComponent(hash[1]); } return myJson; }大致的删除逻辑上文已经描述了，代码部分： &#x2F;&#x2F; 关闭选项标签 closeUrl(menu) { &#x2F;&#x2F; 如果只有一个不可以关闭 if (this.menuList.length &#x3D;&#x3D;&#x3D; 1) return; &#x2F;&#x2F; 如果当前只剩下父页面和对应子页面，则不可以关闭父页面 if (this.menuList.length &#x3D;&#x3D;&#x3D; 2) { if (this.menuList.some(item &#x3D;&gt; item.isChild &amp;&amp; (item.parComponent &#x3D;&#x3D;&#x3D; menu.componentName || item.commonComponent &#x3D;&#x3D;&#x3D; menu.componentName))) { return; } } &#x2F;&#x2F; 当前关闭的是第几个路由 const index &#x3D; this.menuList.findIndex(p &#x3D;&gt; p.url &#x3D;&#x3D;&#x3D; menu.url); if (index &#x3D;&#x3D;&#x3D; -1) { &#x2F;&#x2F; 子页面的子页面返回子页面时造成的 （坏笑 return; } &#x2F;&#x2F; 寻找可能存在的子页面 const childComponent &#x3D; this.menuList.filter(item &#x3D;&gt; this.menuList[index].isChild &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.parComponent &#x3D;&#x3D;&#x3D; this.menuList[index].componentName) || []; &#x2F;&#x2F; 寻找可能存在的子页面的剩下子页面 this.menuList.filter(item &#x3D;&gt; this.menuList[index].isChild &#x3D;&#x3D;&#x3D; undefined &#x2F;&#x2F; 本身必须是父页面 &amp;&amp; item.commonComponent &#x3D;&#x3D;&#x3D; this.menuList[index].componentName &#x2F;&#x2F; 祖先 &amp;&amp; item.parComponent !&#x3D;&#x3D; this.menuList[index].componentName &#x2F;&#x2F; 不是第一个子页面 ).forEach(item &#x3D;&gt; { childComponent.push(item); }); &#x2F;&#x2F; 删除 if (childComponent.length &#x3D;&#x3D;&#x3D; 0) { this.deleteTabs(menu); } else { this.modal.confirm({ nzContent: &#39;【&#39; + childComponent[0].title + &#39;】页将一并关闭，是否继续？&#39;, nzCancelText: &#39;否&#39;, nzOkText: &#39;是&#39;, nzOkType: &#39;danger&#39;, nzOnOk: () &#x3D;&gt; { childComponent.forEach(item &#x3D;&gt; { this.deleteTabs(menu, item); }) } }); } } &#x2F;&#x2F; 执行 Tab 删除 deleteTabs(menu, childComponent &#x3D; null) { const index &#x3D; this.menuList.findIndex(p &#x3D;&gt; p.url &#x3D;&#x3D;&#x3D; menu.url); const indexMenuParam &#x3D; menu.url.indexOf(&#39;?&#39;); const path &#x3D; menu.url.substring(0, indexMenuParam &#x3D;&#x3D;&#x3D; -1 ? menu.url.length : indexMenuParam) + &#39;_&#39; + menu.componentName; this.menuList.splice(index, 1); &#x2F;&#x2F; 删除父 SimpleReuseStrategy.deleteRouteSnapshot(path); &#x2F;&#x2F; 删除复用 &#x2F;&#x2F; 删除子 if (childComponent) { const indexOfChild &#x3D; this.menuList.findIndex(p &#x3D;&gt; p.componentName &#x3D;&#x3D;&#x3D; childComponent.componentName); const indexChildParam &#x3D; childComponent.url.indexOf(&#39;?&#39;); const childPath &#x3D; childComponent.url.substring(0, indexChildParam &#x3D;&#x3D;&#x3D; -1 ? childComponent.url.length : indexChildParam) + &#39;_&#39; + childComponent.componentName; this.menuList.splice(indexOfChild, 1); &#x2F;&#x2F; 删除子页面 SimpleReuseStrategy.deleteRouteSnapshot(childPath); &#x2F;&#x2F; 删除子页面复用 } this.settingsService.setMenuList(this.menuList); &#x2F;&#x2F; 记录 &#x2F;&#x2F; 如果当前删除的对象是当前选中的，那么需要跳转 if (this.currentUrl &#x3D;&#x3D;&#x3D; menu.url) { &#x2F;&#x2F; 显示上一个选中 let menu &#x3D; this.menuList[index - 1]; if (!menu) {&#x2F;&#x2F; 如果上一个没有下一个选中 menu &#x3D; this.menuList[index]; } &#x2F;&#x2F; 跳转路由 this.router.navigate([menu.url]); } }","categories":[{"name":"blog","slug":"blog","permalink":"http://www.woodend.cn/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.woodend.cn/tags/hexo/"}]},{"title":"fuck-categories","slug":"fuck-categories","date":"2021-05-19T09:18:31.000Z","updated":"2021-05-20T09:18:31.000Z","comments":true,"path":"fuck-categories-0d6a65d8ec8d/","link":"","permalink":"http://www.woodend.cn/fuck-categories-0d6a65d8ec8d/","excerpt":"自定义md文章和生成的博客静态文件管理规则","text":"自定义md文章和生成的博客静态文件管理规则 创建新的文章$ hexo new post [文件名称] 将会创建到source/_post/目录下，这里我为了将md文章按照我创建的分类定位，在source/_post/目录下我创建了分类目录，将对应的md文章放入相应的目录中。 将md文章进行分类管理permalink 设置博客访问地址的规则。 permalink: :category&#x2F;:title-:hash&#x2F; 上述规则所产生的效果就是：https://www.woodend.cn/blog/Deploy-Hexo-e7140e18b72a其在public/下生成以分类名命名的目录，配合 post_asset_folder: true 将会生成如下目录结构 public/blog/Deploy-Hexo-e7140e18b72a/index.html 但是上述的配置只能分类管理hexo部署生成后的静态文件，md文章都是在source/_post/目录下的。所以我们可以/source/_post目录下来直接创建分类的目录，区分md文章，同时在生成静态文件之后也会是相同的目录.","categories":[{"name":"begin","slug":"begin","permalink":"http://www.woodend.cn/categories/begin/"}],"tags":[{"name":"begin","slug":"begin","permalink":"http://www.woodend.cn/tags/begin/"}]}],"categories":[{"name":"blog","slug":"blog","permalink":"http://www.woodend.cn/categories/blog/"},{"name":"begin","slug":"begin","permalink":"http://www.woodend.cn/categories/begin/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.woodend.cn/tags/hexo/"},{"name":"begin","slug":"begin","permalink":"http://www.woodend.cn/tags/begin/"}]}